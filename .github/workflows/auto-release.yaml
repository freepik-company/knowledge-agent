name: Auto Release on Push to Main

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'examples/**'
      - '.gitignore'
      - 'LICENSE'

permissions:
  contents: write
  packages: write

jobs:
  auto-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation

      - name: Read Go version from go.mod
        id: read_go_version
        run: |
          go_version_raw=$(grep "^go " go.mod | awk '{print $2}')
          echo "go_version=${go_version_raw}" >> "$GITHUB_OUTPUT"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '${{ steps.read_go_version.outputs.go_version }}'

      - name: Get latest tag
        id: get_latest_tag
        run: |
          # Get latest tag or default to v0.0.0 if none exists
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=${latest_tag}" >> "$GITHUB_OUTPUT"

          # Extract version numbers
          version=${latest_tag#v}
          IFS='.' read -r major minor patch <<< "$version"
          echo "major=${major}" >> "$GITHUB_OUTPUT"
          echo "minor=${minor}" >> "$GITHUB_OUTPUT"
          echo "patch=${patch}" >> "$GITHUB_OUTPUT"

      - name: Determine version bump
        id: version_bump
        run: |
          # Get commit messages since last tag (or all commits if no tag exists)
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"
          if [ "$latest_tag" = "v0.0.0" ]; then
            # No previous tags - get all commits
            commits=$(git log --pretty=format:"%s")
          else
            # Compare against last tag
            commits=$(git log ${latest_tag}..HEAD --pretty=format:"%s")
          fi

          # Check for breaking changes (major bump)
          if echo "$commits" | grep -qiE "^(BREAKING|breaking|break)(\(|:)|!:"; then
            bump_type="major"
          # Check for features (minor bump)
          elif echo "$commits" | grep -qiE "^(feat|feature)(\(|:)"; then
            bump_type="minor"
          # Default to patch bump
          else
            bump_type="patch"
          fi

          echo "bump_type=${bump_type}" >> "$GITHUB_OUTPUT"

          # Calculate new version
          major=${{ steps.get_latest_tag.outputs.major }}
          minor=${{ steps.get_latest_tag.outputs.minor }}
          patch=${{ steps.get_latest_tag.outputs.patch }}

          case "$bump_type" in
            major)
              new_version="v$((major + 1)).0.0"
              ;;
            minor)
              new_version="v${major}.$((minor + 1)).0"
              ;;
            patch)
              new_version="v${major}.${minor}.$((patch + 1))"
              ;;
          esac

          echo "new_version=${new_version}" >> "$GITHUB_OUTPUT"
          echo "ðŸ“¦ Next version will be: ${new_version} (${bump_type} bump)"

      - name: Create and push tag
        id: create_tag
        run: |
          new_version="${{ steps.version_bump.outputs.new_version }}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create annotated tag
          git tag -a "${new_version}" -m "Release ${new_version}"
          git push origin "${new_version}"

          echo "tag_created=true" >> "$GITHUB_OUTPUT"

      - name: Generate changelog
        id: changelog
        run: |
          new_version="${{ steps.version_bump.outputs.new_version }}"
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"

          # Generate changelog from commit messages
          echo "## What's Changed" > CHANGELOG.md
          echo "" >> CHANGELOG.md

          # Group commits by type
          git log ${latest_tag}..HEAD --pretty=format:"%s" | while read -r commit; do
            case "$commit" in
              feat:*|feature:*)
                echo "### âœ¨ Features" >> CHANGELOG_FEATURES.md
                echo "- ${commit#feat:}" | sed 's/^[[:space:]]*//' >> CHANGELOG_FEATURES.md
                ;;
              fix:*)
                echo "### ðŸ› Bug Fixes" >> CHANGELOG_FIXES.md
                echo "- ${commit#fix:}" | sed 's/^[[:space:]]*//' >> CHANGELOG_FIXES.md
                ;;
              docs:*)
                echo "### ðŸ“š Documentation" >> CHANGELOG_DOCS.md
                echo "- ${commit#docs:}" | sed 's/^[[:space:]]*//' >> CHANGELOG_DOCS.md
                ;;
              perf:*)
                echo "### âš¡ Performance" >> CHANGELOG_PERF.md
                echo "- ${commit#perf:}" | sed 's/^[[:space:]]*//' >> CHANGELOG_PERF.md
                ;;
              refactor:*)
                echo "### â™»ï¸ Refactoring" >> CHANGELOG_REFACTOR.md
                echo "- ${commit#refactor:}" | sed 's/^[[:space:]]*//' >> CHANGELOG_REFACTOR.md
                ;;
              test:*)
                echo "### âœ… Tests" >> CHANGELOG_TESTS.md
                echo "- ${commit#test:}" | sed 's/^[[:space:]]*//' >> CHANGELOG_TESTS.md
                ;;
              chore:*|ci:*|build:*)
                echo "### ðŸ”§ Chores & CI" >> CHANGELOG_CHORES.md
                echo "- ${commit#chore:}" | sed 's/^[[:space:]]*//' >> CHANGELOG_CHORES.md
                ;;
              *)
                echo "### ðŸ”„ Other Changes" >> CHANGELOG_OTHER.md
                echo "- ${commit}" >> CHANGELOG_OTHER.md
                ;;
            esac
          done

          # Combine all sections
          for file in CHANGELOG_FEATURES.md CHANGELOG_FIXES.md CHANGELOG_PERF.md CHANGELOG_DOCS.md CHANGELOG_REFACTOR.md CHANGELOG_TESTS.md CHANGELOG_CHORES.md CHANGELOG_OTHER.md; do
            if [ -f "$file" ]; then
              cat "$file" >> CHANGELOG.md
              echo "" >> CHANGELOG.md
              rm "$file"
            fi
          done

          # Add commit count and contributors
          echo "---" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          commit_count=$(git log ${latest_tag}..HEAD --oneline | wc -l)
          echo "**ðŸ“Š Stats**: ${commit_count} commits since ${latest_tag}" >> CHANGELOG.md
          echo "" >> CHANGELOG.md

          # Show changelog
          cat CHANGELOG.md

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          new_version="${{ steps.version_bump.outputs.new_version }}"

          # Create release with custom changelog + auto-generated notes
          gh release create "${new_version}" \
            --title "Release ${new_version}" \
            --notes-file CHANGELOG.md \
            --generate-notes \
            --latest

          echo "âœ… Release ${new_version} created"
          echo "ðŸ”„ Binary and Docker builds will start automatically via release-binaries.yaml and release-docker-images.yaml"
